use std::str::FromStr;
use crate::errata_prelude::ast::{Statement, Literal, Parameter};

grammar;

//starting point - a full script file
pub Script: Vec<Statement> = {
    <Statement*>
};

//statements are the top-level things in the script
pub Statement: Statement = {
    VarDecl,
    FuncDecl,
};

//variable declarations: var x = 3
VarDecl: Statement = {
    "var" <name:Ident> "=" <value:Literal> => {
        let is_private = name.starts_with('_');
        Statement::VarDecl { name, value, is_private }
    }
};

//function declarations with typed parameters
//supports: func foo() { }
//supports: func foo(x: int) { }
//supports: func foo(mut player: Player, amount: int) { }
//supports: mut func increment() { }
FuncDecl: Statement = {
    <is_mut:"mut"?> "func" <name:Ident> "(" <params:Comma<Param>> ")" "{" <body:Statement*> "}" => {
        let is_private = name.starts_with('_');
        Statement::FuncDecl { 
            name, 
            params, 
            body, 
            is_private,
            is_mut: is_mut.is_some(),
        }
    }
};

//single parameter definition
//supports: x: int
//supports: mut player: Player
Param: Parameter = {
    <is_mut:"mut"?> <name:Ident> ":" <type_annotation:Ident> => {
        Parameter {
            name,
            type_annotation,
            is_mut: is_mut.is_some(),
        }
    }
};

//comma-separated list macro
//handles: empty, single item, or multiple items
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//literals, just integers and strings for now
Literal: Literal = {
    <n:Num> => Literal::Int(n),
    <s:Str> => Literal::String(s),
};

//lexer tokens
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
Num: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();
Str: String = r#""[^"]*""# => {
    let s = <>;
    s[1..s.len()-1].to_string() //strip quotes
};