use std::str::FromStr;
use crate::errata_prelude::ast::{Statement, Expression, BinaryOperator, Parameter};

grammar;

//starting point - a full script file
pub Script: Vec<Statement> = {
    <Statement*>
};

//statements are the top-level things in the script
pub Statement: Statement = {
    VarDecl,
    FuncDecl,
    Return,
};

//variable declarations
//var x = 3
//var x: int = 3
//var name: String = "bob"
VarDecl: Statement = {
    "var" <name:Ident> <type_annotation:(":" <Ident>)?> "=" <value:Expression> => {
        let is_private = name.starts_with('_');
        Statement::VarDecl { name, type_annotation, value, is_private }
    }
};

//function declarations with return types
//func foo() { }
//func add(a: int, b: int) -> int { }
//mut func increment() -> int { }
FuncDecl: Statement = {
    <is_mut:"mut"?> "func" <name:Ident> "(" <params:Comma<Param>> ")" <return_type:("->" <Ident>)?> "{" <body:Statement*> "}" => {
        let is_private = name.starts_with('_');
        Statement::FuncDecl { 
            name, 
            params,
            return_type,
            body, 
            is_private,
            is_mut: is_mut.is_some(),
        }
    }
};

//return statement
//return
//return x + 1
Return: Statement = {
    "return" <value:Expression?> => Statement::Return { value }
};

//single parameter definition
//x: int
//mut player: Player
Param: Parameter = {
    <is_mut:"mut"?> <name:Ident> ":" <type_annotation:Ident> => {
        Parameter {
            name,
            type_annotation,
            is_mut: is_mut.is_some(),
        }
    }
};

//comma-separated list macro
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//expressions with operator precedence
//lowest precedence (evaluated last)
pub Expression: Expression = {
    LogicalOrExpr,
};

LogicalOrExpr: Expression = {
    <left:LogicalOrExpr> "||" <right:LogicalAndExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Or,
        right: Box::new(right),
    },
    LogicalAndExpr,
};

LogicalAndExpr: Expression = {
    <left:LogicalAndExpr> "&&" <right:ComparisonExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::And,
        right: Box::new(right),
    },
    ComparisonExpr,
};

ComparisonExpr: Expression = {
    <left:ComparisonExpr> "==" <right:AddSubExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Equals,
        right: Box::new(right),
    },
    <left:ComparisonExpr> "!=" <right:AddSubExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::NotEquals,
        right: Box::new(right),
    },
    <left:ComparisonExpr> "<" <right:AddSubExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Less,
        right: Box::new(right),
    },
    <left:ComparisonExpr> "<=" <right:AddSubExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::LessEqual,
        right: Box::new(right),
    },
    <left:ComparisonExpr> ">" <right:AddSubExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Greater,
        right: Box::new(right),
    },
    <left:ComparisonExpr> ">=" <right:AddSubExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::GreaterEqual,
        right: Box::new(right),
    },
    AddSubExpr,
};

AddSubExpr: Expression = {
    <left:AddSubExpr> "+" <right:MulDivExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Add,
        right: Box::new(right),
    },
    <left:AddSubExpr> "-" <right:MulDivExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Subtract,
        right: Box::new(right),
    },
    MulDivExpr,
};

MulDivExpr: Expression = {
    <left:MulDivExpr> "*" <right:PrimaryExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Multiply,
        right: Box::new(right),
    },
    <left:MulDivExpr> "/" <right:PrimaryExpr> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Divide,
        right: Box::new(right),
    },
    PrimaryExpr,
};

PrimaryExpr: Expression = {
    //literals
    <n:Num> => Expression::IntLiteral(n),
    <s:Str> => Expression::StringLiteral(s),
    
    //function call: foo(a, b, c)
    <name:Ident> "(" <args:Comma<Expression>> ")" => Expression::FunctionCall { name, args },
    
    //variable reference
    <name:Ident> => Expression::Variable(name),
    
    //parenthesised expression for grouping
    "(" <Expression> ")",
};

//lexer tokens
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
Num: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();
Str: String = r#""[^"]*""# => {
    let s = <>;
    s[1..s.len()-1].to_string() //strip quotes
};