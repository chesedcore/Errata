use std::str::FromStr;
use crate::errata_prelude::ast::{Statement, Expression, BinaryOperator, Parameter};

grammar;

//starting point - a full script file
pub Script: Vec<Statement> = {
    <Statement*>
};

//statements are the top-level things in the script
pub Statement: Statement = {
    VarDecl,
    FuncDecl,
    Return,
};

//variable declarations
//var x = 3
//var x: int = 3
VarDecl: Statement = {
    "var" <name:Ident> <type_annotation:(":" <Ident>)?> "=" <value:Expression> => {
        let is_private = name.starts_with('_');
        Statement::VarDecl { name, type_annotation, value, is_private }
    }
};

//function declarations with return types
FuncDecl: Statement = {
    <is_mut:"mut"?> "func" <name:Ident> "(" <params:Comma<Param>> ")" <return_type:("->" <Ident>)?> "{" <body:Statement*> "}" => {
        let is_private = name.starts_with('_');
        Statement::FuncDecl { 
            name, 
            params,
            return_type,
            body, 
            is_private,
            is_mut: is_mut.is_some(),
        }
    }
};

//return statement
Return: Statement = {
    "return" <value:Expression?> => Statement::Return { value }
};

//single parameter definition
Param: Parameter = {
    <is_mut:"mut"?> <name:Ident> ":" <type_annotation:Ident> => {
        Parameter {
            name,
            type_annotation,
            is_mut: is_mut.is_some(),
        }
    }
};

//comma-separated list macro
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//expressions, complex exprs
pub Expression: Expression = {
    #[precedence(level="0")]
    <n:Num> => Expression::IntLiteral(n),
    <s:Str> => Expression::StringLiteral(s),
    <name:Ident> => Expression::Variable(name),
    "(" <Expression> ")",
    
    #[precedence(level="1")]
    <name:Ident> "(" <args:Comma<Expression>> ")" => Expression::FunctionCall { name, args },
    
    #[precedence(level="2")] #[assoc(side="left")]
    <obj:Expression> "." <member:Ident> => Expression::MemberAccess {
        object: Box::new(obj),
        member,
    },
    
    #[precedence(level="3")] #[assoc(side="left")]
    <left:Expression> "*" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Multiply,
        right: Box::new(right),
    },
    <left:Expression> "/" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Divide,
        right: Box::new(right),
    },
    
    #[precedence(level="4")] #[assoc(side="left")]
    <left:Expression> "+" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Add,
        right: Box::new(right),
    },
    <left:Expression> "-" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Subtract,
        right: Box::new(right),
    },
    
    #[precedence(level="5")] #[assoc(side="left")]
    <left:Expression> "==" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Equals,
        right: Box::new(right),
    },
    <left:Expression> "!=" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::NotEquals,
        right: Box::new(right),
    },
    <left:Expression> "<" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Less,
        right: Box::new(right),
    },
    <left:Expression> "<=" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::LessEqual,
        right: Box::new(right),
    },
    <left:Expression> ">" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Greater,
        right: Box::new(right),
    },
    <left:Expression> ">=" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::GreaterEqual,
        right: Box::new(right),
    },
    
    #[precedence(level="6")] #[assoc(side="left")]
    <left:Expression> "&&" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::And,
        right: Box::new(right),
    },
    
    #[precedence(level="7")] #[assoc(side="left")]
    <left:Expression> "||" <right:Expression> => Expression::BinaryOp {
        left: Box::new(left),
        op: BinaryOperator::Or,
        right: Box::new(right),
    },
};

//lexer tokens
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
Num: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();
Str: String = r#""[^"]*""# => {
    let s = <>;
    s[1..s.len()-1].to_string() //strip quotes
};